## 문제
**문제**  
블랙 프라이데이는 미국에서 (11월 넷째 주 목요일인) 추수 감사절 다음 금요일입니다. 2000년대 초반부터 미국에서는 크리스마스 쇼핑 시즌의 시작으로 여겨져, 많은 소매 상인이 일찍 문을 열고 홍보용 할인을 제공합니다. (출처 : 위키피디아)  

당신은 전자제품 매장의 IT 지원 부서에서 일하고 있습니다. 올해 매장이 너무 붐비는 것을 막기 위해, 경영 부서는 매장에 들어오는 사람의 수를 제한하기로 결정했습니다. 입구에서 손님을 크기 n의 묶음으로 나눈 후 다음의 과정을 수행할 예정입니다: 모든 n명의 손님이 주사위를 굴려, 그 결과를 a1, a2, ..., an으로 저장합니다. 꼼수를 막기 위해 가장 높은 눈을 낸 손님을 입장시키는 것이 아닌, 유일한 눈 중 가장 높은 눈을 낸 손님을 입장시킬 것입니다. 선택되지 않은 나머지 손님은 줄 맨 뒤로 이동합니다. 승자가 없으면, 과정을 반복합니다.  

예를 들어 세 명이 있고 주사위의 눈이 6, 6, 5였다면 첫 번째 손님과 두 번째 손님의 눈이 더 높지만 둘이 같은 값을 냈으므로 세 번째 손님이 승자가 됩니다. 만약 세 번째 손님의 눈도 6이었다면, 승자는 없습니다. 경영 부서는 당신에게 승자를 고르는 프로그램을 작성해달라고 부탁합니다.  

<br/>

**입력**  
첫 줄에 묶음의 크기를 나타내는 하나의 정수 1 <= n <= 100이 주어집니다. 둘째 줄에 각 손님이 굴린 주사위의 눈을 나타내는 n개의 정수 a1, a2, ..., an이 주어집니다. (모든 1 <= i <= n에 대해 1 <= ai <= 6입니다.)  

<br/>

**출력**  
유일한 눈 중 가장 높은 눈을 낸 손님의 인덱스를 출력하거나, 아무도 유일한 눈을 내지 않았을 경우 (인용구를 제외하고) "none"을 출력합니다.  

<br/>

번역 출처 : https://www.acmicpc.net/board/view/93693

## 아이디어
Implement, Hash Map, Sorting  

`unordered_map<int, int>`로 각 수가 몇 번 나왔는지 카운팅한다
```cpp
int n, a[100];
unordered_map<int, int> um;
scanf("%d", &n);
for(int i=0 ; i<n ; i++) {
	scanf("%d", &a[i]);
	um[a[i]]++;
}
```
나온 수 중 큰 순서대로 정렬하기 위해 `vector<pair<int, int>>`에 먼저 담고  
`vector<pair<int, int>>`를 정렬하면 오름차순이 된다  
이를 뒤집어 내림차순으로 만든다
```cpp
vector<pair<int, int>> v;
for(unordered_map<int, int>::iterator iter=um.begin() ; iter!=um.end() ; iter++)
	v.push_back({iter->first, iter->second});
sort(v.begin(), v.end());
reverse(v.begin(), v.end());
```
정렬된 `vector<>`에서 유일한 눈(1명)을 찾으면 배열에서 그게 몇 번째에 있는지 찾는다
```cpp
for(int i=0 ; i<v.size() ; i++)
	if(v[i].second==1)
		for(int j=0 ; j<n ; j++)
			if(v[i].first==a[j]) {
				printf("%d", j+1);
				return 0;
			}
puts("none");
```