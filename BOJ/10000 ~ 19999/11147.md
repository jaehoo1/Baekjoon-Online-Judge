## 문제
테스트 케이스 T가 주어진다.  
각 테스트 케이스에는 도시의 개수 N, 여행순서, 그래프가 주어진다.  
톰은 여행이 끝나면 다시 출발점으로 돌아온다.  
G[i][j]의 경로가 없는 경우는 -1로 주어진다.  
여행을 하는데 가장 적은 비용을 구하여라.  
만약 여행할 수 없다면 impossible 출력

## 아이디어
Floyd Warshall  
모든 노드에서 모든 노드로의 최단비용이 필요하고 N이 작으므로  
플로이드 와샬 알고리즘을 적용한다  
  
여행 순서를 입력받고 여행이 끝나면 출발지로 돌아온다고 했으므로  
여행 순서의 마지막에 출발지점을 넣어준다
```
sum=0;
impossible=0;
scanf("%d", &N);
for(i=0 ; i<N ; i++)
	scanf("%d", &arr[i]);
arr[i]=arr[0];
```
그래프를 입력받는다  
-1은 경로가 없음을 의미한다
```
for(i=0 ; i<N ; i++)
	for(j=0 ; j<N ; j++) {
		scanf("%d", &G[i][j]);
		if(G[i][j]==-1)
			G[i][j]=INF;
	}
```
i에서 j노드로 갈 때 k노드를 거쳐서 갈 때 거리가 짧아진다면 갱신한다
```
for(k=0 ; k<N ; k++)
	for(i=0 ; i<N ; i++)
		for(j=0 ; j<N ; j++)
			if(G[i][k]+G[k][j]<G[i][j])
				G[i][j]=G[i][k]+G[k][j];
```
주어진 여행 순서대로 최단 비용을 더해간다
```
for(i=0 ; i<N ; i++) {
	if(G[arr[i]][arr[i+1]]==INF) {
		impossible=1;
		break;
	}
	sum+=G[arr[i]][arr[i+1]];
}
```
