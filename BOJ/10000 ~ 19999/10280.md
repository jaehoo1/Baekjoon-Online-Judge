# [10280 : Pizza voting](https://www.acmicpc.net/problem/10280)
https://www.acmicpc.net/problem/10280

## 문제
피자를 3명(Alice, Bob, 나)이서 Round Robin 방식의 거부권 투표를 통해 1개가 남을 때 까지 반복 투표한다.  
각자 투표를 하는 방식은 다음과 같을 때, 내가 좋아하는 피자를 먹을 수 있는지 구하는 문제
- Alice : (남아있는 피자 중) 칼로리가 제일 높은 피자
- Bob : (남아있는 피자 중) 칼로리가 제일 적은 피자
- 나 : 내가 좋아하는 피자를 최대한 먹을 수 있게끔 투표

## 아이디어
Greedy, Simulation(Implementation)

내가 좋아하는 피자의 인덱스가 주어지므로, Alice와 Bob이 투표 한 이후 남아있는 인덱스 중 내가 좋아하는 피자와 가장 멀리 떨어진 인덱스를 고르면 된다.

피자 클래스, 입력 처리
```java
class Pizza {

    int calories;
    String name;
    boolean vetoed;

    public Pizza(int calories, String name) {
        this.calories = calories;
        this.name = name;
        this.vetoed = false;
    }
}

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer st = new StringTokenizer(br.readLine());
int n = Integer.parseInt(st.nextToken());
int p = Integer.parseInt(st.nextToken()) - 1;
Pizza[] pizzas = new Pizza[n];
for (int i = 0; i < n; i++) {
    st = new StringTokenizer(br.readLine());
    pizzas[i] = new Pizza(Integer.parseInt(st.nextToken()), st.nextToken());
}
```

Alice는 가장 밑의 인덱스(칼로리 제일 높은거), Bob은 가장 처음 인덱스(칼로리 제일 낮은거) 부터 투표를 시작하고 나는 내 피자의 인덱스와 가장 멀리 떨어진 것을 고르면 된다.
```java
int alice = n - 1, bob = 0;

for (int i = 0; i < n - 1; i++) {
    if (i % 3 == 0) {              // Alice 투표
        pizzas[alice--].vetoed = true;
    } else if (i % 3 == 1) {        // Bob 투표
        pizzas[bob++].vetoed = true;
    } else {                        // 나 투표
        pizzas[alice - p > p - bob ? alice-- : bob++].vetoed = true;
    }
}
System.out.println(pizzas[p].vetoed ? "NO" : "YES");
```