# [10981 : HEADING TO WORLD FINALS](https://www.acmicpc.net/problem/10981)
https://www.acmicpc.net/problem/10981

## 아이디어
Sorting, Hash Map(Data Structure)

각 대학별 1팀만 출전 가능 → 대학교를 key로, 팀을 value 로 가지는 `HashMap<String, Team>` 으로 데이터를 저장하면 편할듯

`Team` 구현
```java
class Team {

    String name;
    int solved, penalty;

    public Team(String name, int solved, int penalty) {
        this.name = name;
        this.solved = solved;
        this.penalty = penalty;
    }
}
```

팀들을 입력받되, 한 대학에 여러 팀이 존재한다면 더 상위 점수를 가지는 팀만 남긴다.
```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

StringTokenizer st = new StringTokenizer(br.readLine());
int N = Integer.parseInt(st.nextToken());
int K = Integer.parseInt(st.nextToken());
Map<String, Team> map = new HashMap<>();
for (int i = 0; i < N; i++) {
    st = new StringTokenizer(br.readLine());
    String univ = st.nextToken();
    String teamName = st.nextToken();
    int solved = Integer.parseInt(st.nextToken());
    int penalty = Integer.parseInt(st.nextToken());
    map.compute(univ, (k, v) -> {
        if (v == null) {
            return new Team(teamName, solved, penalty);
        }
        if (v.solved < solved) {
            return new Team(teamName, solved, penalty);
        } else if (v.solved > solved) {
            return v;
        }
        return v.penalty < penalty ? v : new Team(teamName, solved, penalty);
    });
}
```

팀들을 높은 점수순으로 정렬하고 위에서 `K` 개만 출력한다.
```java
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

List<Team> teams = new ArrayList<>(map.values());
teams.sort((t1, t2) -> {
    if (t1.solved == t2.solved) {
        return t1.penalty - t2.penalty;
    }
    return t2.solved - t1.solved;
});
for (int i = 0; i < K; i++) {
    bw.write(teams.get(i).name + "\n");
}
```