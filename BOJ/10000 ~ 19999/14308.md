# [14308 : Safe Squares (Small)](https://www.acmicpc.net/problem/14308)
https://www.acmicpc.net/problem/14308

## 문제
몬스터들의 좌표가 주어질 때 안전한 (정사각형) 영역(N × N)의 개수를 구하는 문제

## 아이디어
Brute Force, Implementation

몬스터 좌표를 `boolean[][]` 으로 받아 있는 곳에 `true`로 표시한다고 생각할 때 특정 좌표로 부터 N × N 영역이 안전한 지는 완전탐색으로 구할 수 있다.  
(그냥 정사각형 안에 다 보면 됨)
```java
static boolean[][] monster;
static int R, C;

/**
 * x, y 좌표부터 l 길이를 가지는 정사각형이 안전한가?
 * 
 * @param x 행(위)
 * @param y 열(왼쪽)
 * @param l (정사각형)길이
 * @return x ~ x + l, y ~ y + l 까지의 정사각형 필드가 안전한지 여부
 */
static boolean isSafe(int x, int y, int l) {
    for (int i = x; i < x + l; i++) {
        if (i >= R) {
            return false;
        }
        for (int j = y; j < y + l; j++) {
            if (j >= C) {
                return false;
            }
            if (monster[i][j]) {
                return false;
            }
        }
    }
    return true;
}
```

R, C 범위가 작기 때문에 모든 경우를 다 찾아볼 수 있다.
```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
int T = Integer.parseInt(br.readLine());
for (int t = 1; t <= T; t++) {
    StringTokenizer st = new StringTokenizer(br.readLine());
    R = Integer.parseInt(st.nextToken());
    C = Integer.parseInt(st.nextToken());
    int K = Integer.parseInt(st.nextToken());
    monster = new boolean[R][C];
    while (K-- > 0) {
        st = new StringTokenizer(br.readLine());
        // 몬스터 위치 표시
        monster[Integer.parseInt(st.nextToken())][Integer.parseInt(st.nextToken())] = true;
    }
    int safeZones = 0;
    // 안전한 (정사각형) 영역 찾기
    for (int l = 1; l <= Math.min(R, C); l++) {
        for (int i = 0; i < R; i++) {
            for (int j = 0; j < C; j++) {
                if (isSafe(i, j, l)) {
                    safeZones++;
                }
            }
        }
    }
    bw.write("Case #" + t + ": " + safeZones + "\n");
}
```