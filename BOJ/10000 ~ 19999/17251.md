## 아이디어
Dynamic Programming  
  
홍팀과 청팀의 승패는 각 팀별 힘이 가장 높은 사람에 의해 결정된다  
→ 홍팀과 청팀을 나눴을 때(나누는 기준선을 정했을 때) 각 팀별 가장 힘이 높은 사람을 구해야함  
  
각 팀별 힘이 가장 높은 사람을 기준선을 정했을 때 구하기 시작하면  
기준선이 될 수 있는 경우는 `N`개이기 때문에 O(N^2)이 되어 TLE가 날 것  
  
기준선을 정하자 마자 팀별 힘이 가장 높은 사람을 구할 수 있는 방법이 있다  
어차피 기준선을 기준으로 왼쪽은 홍팀, 오른쪽은 청팀이기 때문에  
자기 자신을 기준으로 왼쪽/오른쪽의 최대값을 미리 구해놓으면  
자신의 옆에 기준선이 생겼을 때 저장해놨던(DP) 값을 이용하여  
그 경우의 승패를 바로 구별할 수 있다  
  
예제 입력 1을 예로 들자면

|idx|0|1|2|3|4|5|
|---|---|---|---|---|---|---|
|arr[idx]|9|15|18|7|13|11|
|leftmax|9|15|18|18|18|x|
|rightmax|x|18|18|13|13|11|

인덱스 0 ~ 1 사이에 기준선이 생길 경우 : 홍팀 점수(`leftmax[0]`) < 청팀 점수(`rightmax[1]`)  
인덱스 1 ~ 2 사이에 기준선이 생길 경우 : 홍팀 점수(`leftmax[1]`) < 청팀 점수(`rightmax[2]`)  
인덱스 2 ~ 3 사이에 기준선이 생길 경우 : 홍팀 점수(`leftmax[2]`) > 청팀 점수(`rightmax[3]`)  
인덱스 3 ~ 4 사이에 기준선이 생길 경우 : 홍팀 점수(`leftmax[3]`) > 청팀 점수(`rightmax[4]`)  
인덱스 4 ~ 5 사이에 기준선이 생길 경우 : 홍팀 점수(`leftmax[4]`) > 청팀 점수(`rightmax[5]`)  
  
![image](https://user-images.githubusercontent.com/44667299/168453687-eb230873-3a2e-4a71-bac2-082e36ae5d8c.png)  
  
자신의 인덱스 옆에 기준선이 놓였을 경우 홍팀과 청팀의 점수의 최대값을 구해놓으면 되겠다  
  
왼쪽 최대값(홍팀 점수)을 입력받으며 구한다
```c
int max(int a, int b) { return a>b?a:b; }

int N, i, arr[1000000], dp1[1000000];
scanf("%d%d", &N, &arr[0]);
dp1[0]=arr[0];
for(i=1 ; i<N ; i++) {
	scanf("%d", &arr[i]);
	dp1[i]=max(dp1[i-1], arr[i]);
}
```
오른쪽 최대값(청팀 점수)도 구한다
```c
int dp2[1000000];
dp2[N-1]=arr[N-1];
for(i=N-2 ; i!=0 ; i--)
	dp2[i]=max(dp2[i+1], arr[i]);
```
위의 그림에서 처럼 자신의 옆에 경계선이 놓일 경우에  
홍팀 점수가 클지 청팀 점수가 클지 대각선 비교를 통해 판단
```c
int R=0, B=0;
for(i=0 ; i<N-1 ; i++)
	if(dp1[i]>dp2[i+1])
		R++;
	else if(dp1[i]<dp2[i+1])
		B++;
```
