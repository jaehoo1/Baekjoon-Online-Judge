# [13908 : 비밀번호](https://www.acmicpc.net/problem/13908)
https://www.acmicpc.net/problem/13908

## 아이디어
Brute Force, Bitmask

`n`의 제한만 보고 처음에는 백트래킹 완전 탐색으로 풀 수 있는 문제라 생각하고 단순하게 코드를 짰다.
```java
static int n, m;
static int validCnt;
static char[] stack;
static List<Character> included;

/** 가능한 비밀번호인지 */
static boolean isValidPassword(String password) {
    boolean[] include = new boolean[m];
    for (int i = 0; i < n; i++) {
        char c = password.charAt(i);
        for (int j = 0; j < m; j++) {
            if (c == included.get(j)) {
                include[j] = true;
                break;
            }
        }
    }
    for (int i = 0; i < m; i++) {
        if (!include[i]) {
            return false;
        }
    }
    return true;
}

/** 백트래킹으로 n자리수 모든 비밀번호 생성 */
static void makePasswords(int depth) {
    if (depth == n) {
        if (isValidPassword(new String(stack))) {
            validCnt++;
        }
        return;
    }
    for (int i = 0; i < 10; i++) {
        stack[depth] = (char) (i + '0');
        makePasswords(depth + 1);
    }
}

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer st = new StringTokenizer(br.readLine());
n = Integer.parseInt(st.nextToken());
stack = new char[n];
m = Integer.parseInt(st.nextToken());
if (m > 0) {
    included = new ArrayList<>(m);
    st = new StringTokenizer(br.readLine());
    for (int i = 0; i < m; i++) {
        included.add(st.nextToken().charAt(0));
    }
}
makePasswords(0);
System.out.println(validCnt);
```

그런데 메모리 초과가 났다. Java 언어로 제출을 했고 `isValidPassword()`, `makePasswords()` 메서드에서 `new boolean[]` 과 `new String()` 객체를 수없이 만들면서 GC 시점이 늦어져 메모리 초과가 일어났을 것 같다. (문제의 메모리 제한도 작은편)

메모리 / GC를 직접 컨트롤 할 수는 없으니, 메모리를 최대한 아껴 설계를 해야한다

기존의 재귀 호출 스택 방식이던 백트래킹을 반복문으로, `String`으로 처리하던 자리수 판별은 `int` 타입으로, 나온 자리수 판별 배열 `boolean[]`은 비트마스킹을 적용해 메모리를 최대한 아끼는 로직으로 리팩터링하였다.
```java
static int n, m;
static List<Integer> included;

static boolean isValidPassword(int password) {
    int bitmask = 0;
    for (int i = 0; i < n; i++) {
        int pow = (int) Math.pow(10, n - i - 1);
        int div = password / pow;
        password %= pow;
        for (int j = 0; j < m; j++) {
            if (included.get(j) == div) {
                bitmask |= 1 << j;
            }
        }
    }
    return bitmask == (1 << m) - 1;
}

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer st = new StringTokenizer(br.readLine());
n = Integer.parseInt(st.nextToken());
m = Integer.parseInt(st.nextToken());
if (m > 0) {
    included = new ArrayList<>(m);
    st = new StringTokenizer(br.readLine());
    for (int i = 0; i < m; i++) {
        included.add(Integer.valueOf(st.nextToken()));
    }
}
int maxNum = Integer.parseInt(1 + "0".repeat(n));
int validPassword = 0;
for (int i = 0; i < maxNum; i++) {
    if (isValidPassword(i)) {
        validPassword++;
    }
}
System.out.println(validPassword);
```