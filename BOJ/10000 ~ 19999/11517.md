# [11517 : Positive Con Sequences](https://www.acmicpc.net/problem/11517)
https://www.acmicpc.net/problem/11517

## 문제
빈 값(-1)이 하니 있는 수열이 주어진다. 주어진 수열이 등차/등비수열인지 확인하고 빈 칸에 들어갈 값을 구하는 문제

## 아이디어
Case Work, Brute Force, Implementation

수열은 4개의 수와 1개의 빈자리로 이뤄지므로, 비어있지 않은 두 개(이상)의 수는 무조건 붙어 있을 수 밖에 없다.  
2개 붙어있는 인덱스와 빈 자리 인덱스를 구하는 함수
```java
/** 2개 이상의 비어있지 않은 인덱스를 구함 */
static int findValidIndex(int[] arr) {
    for (int i = 0; i < 3; i++) {
        if (arr[i] != -1 && arr[i + 1] != -1) {
            return i;
        }
    }
    return -1;
}

/** 비어있는 인덱스를 구함 */
static int findMissingIndex(int[] arr) {
    for (int i = 0; i < 4; i++) {
        if (arr[i] == -1) {
            return i;
        }
    }
    return -1;
}
```

붙어있는 두 개의 수로 등차/등비를 구할 수 있고, 이를 통해 해당 수열이 등차/등비수열인지 구할 수 있다.
```java
/** 등차를 구해 등차수열인지 확인 */
static boolean isArithmeticSequence(int[] sequence) {
    int[] copied = Arrays.copyOf(sequence, 4);
    int validIndex = findValidIndex(copied);
    int diff = copied[validIndex + 1] - copied[validIndex];
    int missingIndex = findMissingIndex(copied);
    copied[missingIndex] = missingIndex == 0
            ? copied[missingIndex + 1] - diff
            : copied[missingIndex - 1] + diff;
    if (copied[missingIndex] < 1 || copied[missingIndex] > 10000) {
        return false;
    }
    for (int i = 0; i < 3; i++) {
        if (copied[i] + diff != copied[i + 1]) {
            return false;
        }
    }
    System.arraycopy(copied, 0, sequence, 0, 4);
    return true;
}

/** 등비를 구해 등비수열인지 확인 */
static boolean isGeometricSequence(int[] sequence) {
    int[] copied = Arrays.copyOf(sequence, 4);
    int validIndex = findValidIndex(sequence);
    int ratio = copied[validIndex + 1] / copied[validIndex];
    int missingIndex = findMissingIndex(copied);
    copied[missingIndex] = missingIndex == 0
            ? copied[missingIndex + 1] / ratio
            : copied[missingIndex - 1] * ratio;
    if (copied[missingIndex] < 1 || copied[missingIndex] > 10000) {
        return false;
    }
    for (int i = 0; i < 3; i++) {
        if (copied[i] * ratio != copied[i + 1]) {
            return false;
        }
    }
    System.arraycopy(copied, 0, sequence, 0, 4);
    return true;
}


BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

int[] ints = new int[4];
while (true) {
    StringTokenizer st = new StringTokenizer(br.readLine());
    for (int i = 0; i < 4; i++) {
        ints[i] = Integer.parseInt(st.nextToken());
    }
    if (Arrays.stream(ints).allMatch(i -> i == -1)) {
        break;
    }
    int missingIndex = findMissingIndex(ints);
    bw.write(isArithmeticSequence(ints) || isGeometricSequence(ints) ? ints[missingIndex] + "\n" : "-1\n");
}
```