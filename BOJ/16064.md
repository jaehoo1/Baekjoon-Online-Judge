## 문제
스키를 가장 길게 탈 수 있는 경로를 구하여라  
한 노드에서 출발하여 가장 긴 경로를 구하면 된다  
예제 입력 1의 경우
```
5 5
1 2 15
2 3 12
1 4 17
4 2 11
5 4 9
```
가 주어지는데, 1 → 4 → 2 → 3 의 경로로 가면 40을 구할 수 있다.  
예제 입력 2의 경우
```
6 6
1 2 2
4 5 2
2 3 3
1 3 2
5 6 2
1 2 4
```
가 주어지는데, 1 → 2 → 3 의 경로로 가면 7을 구할 수 있다.  
1 → 2 로 가는 경로는 두 가지가 있는데, 더 긴 경로를 선택하면 된다

## 아이디어
Floyd Warshall  
모든 정점에서 모든 정점으로의 길게 갈 수 있는 거리를 구해야하므로  
플로이드 와샬 알고리즘을 적용한다  
  
dp배열을 초기화한다
```
for(i=1 ; i<=n ; i++)
	for(j=1 ; j<=n ; j++)
		dp[i][j]=INF;
```
간선들을 입력받는데, 시작과 끝 정점이 같은 간선이 들어올 수 있다  
이 때는 거리가 더 긴 간선을 택해야한다
```
while(m--) {
	scanf("%d%d%d", &s, &t, &c);
	if(dp[s][t]==INF)
		dp[s][t]=c;
	else if(c>dp[s][t])
		dp[s][t]=c;
}
```
i에서 k를 거쳐서 j를 갈 수 있고, 그 거리가 i에서 j로 바로 갈 때보다  
(혹은 전에 갱신했던 거리보다) 더 길어진다면 값을 갱신한다
```
for(k=1 ; k<=n ; k++)
	for(i=1 ; i<=n ; i++)
		for(j=1 ; j<=n ; j++)
			if(dp[i][k]!=INF&&dp[k][j]!=INF)
				if(dp[i][j]==INF)
					dp[i][j]=dp[i][k]+dp[k][j];
				else if(dp[i][j]<dp[i][k]+dp[k][j])
					dp[i][j]=dp[i][k]+dp[k][j];
```
dp 테이블 중 최대값을 찾는다
```
for(i=1 ; i<=n ; i++)
	for(j=1 ; j<=n ; j++)
		if(dp[i][j]!=INF&&dp[i][j]>max)
			max=dp[i][j];
```
