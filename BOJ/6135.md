## 문제
소가 몇 가지 매우 짧은 장애물을 뛰어 넘기는 것은 그리 어렵지 않지만,  
하나의 키가 큰 장애물은 매우 스트레스가 될 수 있다.  
따라서, 소들이 뛰어넘어야 하는 가장 높은 장애물의 높이에 대해서만 고려한다.  
  
N개의 노드와 M개의 단방향 간선이 주어진다. 각 간선마다 S, E, H가 주어진다.  
S : 출발노드, E : 도착노드, H : 높이(비용)  
  
T개의 쿼리가 주어진다. 쿼리는 A, B로 주어질 때, A노드에서 B노드로 갈 때  
가장 높은 장애물의 높이를 최소화하는 경로를 원한다. 그 높이를 출력하라.

## 아이디어
Floyd Warshall  
플로이드 와샬과 유사하게 짜되, 저장하는 값을 두 간선의 합이 아닌 두 간선중 큰 값으로 저장한다  
(i에서 j로 갈 때 k를 거쳐서 가면 최단 거리가 갱신될 경우 max(G[i][k], G[k][j])로 갱신)  
```
for(k=1 ; k<=N ; k++)
	for(i=1 ; i<=N ; i++)
		for(j=1 ; j<=N ; j++)
			if(max(G[i][k], G[k][j])<G[i][j])
				G[i][j]=max(G[i][k], G[k][j]);
```
