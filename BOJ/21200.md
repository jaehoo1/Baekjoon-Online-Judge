## 문제
**문제**  

마법 공룡 퍼프는 유명한 마술사입니다. 코로나 때문에 현재는 최신 화상 회의 도구를 이용해 공주님 앞에서만 공연을 할 수 있죠. 따라서 대면 공연일 때 쓰던 많은 마술을 하지 못해, 새로운 마술을 개발하기로 했습니다.  

퍼프는 공주를 위해 다음과 같은 독심술 마술을 하기로 했습니다. 우선, 퍼프는 책상에 N개의 카드를 깔아 놓습니다. 각 카드는 1, ..., N까지 중 고유한 숫자 하나를 값으로 지닙니다. 공연을 시작하기 전에 퍼프는 카드 값 중 하나를 예상 값으로 적어 놓고, 밀봉한 후 공주에게 편지로 보냈습니다.  

공연 도중, 퍼프는 공주에게 남은 카드 중 몇 개를 골라 달라고 부탁했습니다. 공주에게 최소 하나는 고르되 남아있는 카드 모두를 고르지는 말라고 신신당부했죠. 공주가 퍼프에게 무슨 카드를 골랐는지 말하면, 퍼프는 "그 카드를 가지고 있으세요" 또는 "그 카드를 버리세요" 중 하나를 말합니다. 첫 번째 경우, 고른 카드는 남고 남은 모든 카드는 책상에서 제거됩니다. 두 번째 경우, 고른 카드는 버려지고 나머지 카드는 유지됩니다. 카드가 한 장 남을 때까지 이 과정을 반복합니다. 한 장만 남아 퍼프가 공주에게 편지를 열어보라 하면, 놀랍게도 예상 값이 책상에 남은 카드의 값과 같을 것입니다.  

퍼프가 각 단계에서 올바른 대답을 할 수 있도록 도와줍시다.  

<br/>

**입력**  

첫 줄에 세 정수로 카드의 수를 나타내는 N (2 <= N <= 200), 비밀인 예측 값 P (1 <= P <= N), 단계의 수 S (1 <= S <= N -1)가 주어집니다.  

다음 S개의 줄에 각 단계에서 공주의 선택이 주어집니다. 각 줄에는 선택한 카드의 수 m(1 <= m <= N-1)이 주어지고, 그 뒤에 고른 카드의 값을 나타내는 m개의 서로 다른 정수가 이어집니다. 퍼프가 이전 단계를 정확히 수행했을 경우, 공주가 남아있는 카드만 고르는 것은 보장됩니다. 또한, 공주는 최소 한 장을 고르되 남은 모든 카드를 고르지는 않을 것입니다.  

퍼프가 S개의 단계를 정확히 수행했을 경우 S개의 단계 이후 하나의 카드만 남는 것은 보장됩니다.  

<br/>

**출력**  

각 단계마다, 한 줄에 각각 고른 카드를 유지했을 경우와 제거했을 경우를 나타내는 KEEP 또는 REMOVE를 출력합니다.  

<br/>

번역 출처 : https://www.acmicpc.net/board/view/89043

## 아이디어
Implement  
  
각 입력마다 `P`가 들어오는지만 확인하여  
`P`가 들어올 경우에만 `"KEEP"`을 출력해주면 된다
```c
int N, P, S, m, card, keep;
scanf("%d%d%d", &N, &P, &S);
while(S--) {
	keep=0;
	scanf("%d", &m);
	while(m--) {
		scanf("%d", &card);
		if(card==P)
			keep=1;
	}
	puts(keep?"KEEP":"REMOVE");
}
```
