# [1497 : 기타콘서트](https://www.acmicpc.net/problem/1497)
https://www.acmicpc.net/problem/1497

## 아이디어
Backtracking(Brute Force)

N의 개수가 작기 때문에 모든 경우의 수( $O(2^N)$ )를 탐색해도 될거 같다.  
↓  
모든 기타에 대해 포함 / 제외시키는 로직을 완전 탐색 로직을 작성한다.

입력 처리
```java
static int N, M;
static String[] guitarsAvailableSongs;

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer st = new StringTokenizer(br.readLine());
N = Integer.parseInt(st.nextToken());
M = Integer.parseInt(st.nextToken());
guitarsAvailableSongs = new String[N];
for (int i = 0; i < N; i++) {
    st = new StringTokenizer(br.readLine());
    st.nextToken();     // 기타 이름은 필요 없어서 버림
    guitarsAvailableSongs[i] = st.nextToken();
}
```

현재 연주 가능한 곡들에서 기타를 추가했을 때 몇 곡이 연주 가능한지를 셀 수 있어야 한다.
```java
// String(availableSongs)에서 Y 개수가 연주 가능한 곡의 개수

static String importGuitar(String availableSongs, String guitarSongs) {
    char[] chars = availableSongs.toCharArray();
    for (int i = 0; i < M; i++) {
        if (guitarSongs.charAt(i) == 'Y') {
            chars[i] = 'Y';
        }
    }
    return new String(chars);
}

static String importGuitar(String availableSongs, int guitarIdx) {
    return importGuitar(availableSongs, guitarsAvailableSongs[guitarIdx]);
}

static int availableSongsCount(String availableSongs) {
    return IntStream.range(0, M)
            .map((i) -> availableSongs.charAt(i) == 'Y' ? 1 : 0)
            .sum();
}
```

기타를 포함/제외하는 모든 경우의 수를 탐색해 연주할 수 있는 최대 곡과, 그 때의 최소 기타 개수를 구한다.
```java
static int maxAvailableSongs, minGuitarCount = Integer.MAX_VALUE;
static boolean[] visited;

static void chooseGuitar(int depth, String availableSongs) {
    // 현재의 상태에서 연주할 수 있는 곡의 개수
    int curAvailableSongsCount = availableSongsCount(availableSongs);

    // 최대 연주곡 / 최소 기타 개수 갱신
    if (curAvailableSongsCount > maxAvailableSongs) {
        maxAvailableSongs = curAvailableSongsCount;
        minGuitarCount = depth;
    } else if (curAvailableSongsCount == maxAvailableSongs) {
        minGuitarCount = Math.min(minGuitarCount, depth);
    }

    // 이미 모든 곡을 연주할 수 있다면 pruning
    if (depth == N || curAvailableSongsCount == M) {
        return;
    }

    // 다음 기타를 포함&제외시킴
    for (int i = depth; i < N; i++) {
        if (visited[i]) {
            continue;
        }
        visited[i] = true;
        chooseGuitar(depth + 1, importGuitar(availableSongs, i));
        visited[i] = false;
    }
}

chooseGuitar(0, "N".repeat(M));     // 아무것도 고르지 않은 상태(guitar 개수 = 0)
System.out.println(maxAvailableSongs == 0 ? -1 : minGuitarCount);
```