## 아이디어1(TLE)
필요한 건 거리의 절대값이다. y-x  
경우의 수를 살펴봐서 규칙성을 찾는다.  
|y-x|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|...|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|res|1|2|3|3|4|4|5|5|5|6|6|6|7|7|7|7|8|8|8|8|9|...|

같은 값이 n번 나오는 게 두 번 반복된 후, n이 증가하고 반복되는 규칙성을 발견할 수 있다.  
이를 코드화 한다.  
```
y-=x;
if(y==1||y==2) {
	printf("%d\n", y);
	continue;
}
res=3;
dbchk=0;
next=2;	temp=0;
for(i=3 ; i<=y ; i++) {
	if(temp==next) {
		res++;
		dbchk++;
		temp=0;
	}
	if(dbchk==2) {
		dbchk=0;
		next++;
	}
	temp++;
}
```
... 해서 제출하면 TLE가 나온다.  

## 아이디어2
TLE가 나왔기 때문에 좀 더 단순화가 필요하다.  
위의 반복문은 1씩 증가하는데, 이 때문에 시간이 상당히 걸릴 것으로 예상된다.  
위에서 바뀌는 숫자들 중 절반은 제곱수다.  
y-x가 제곱수라면 res=sqrt(y-x)*2-1로 구할 수 있고,  
제곱수가 아니라면  
그것보다 작은 제곱수 ~ 그 다음 제곱수 의 중간보다 작냐 크거나 같냐를 구분지어 구한다.  
```
//ifpow(x)는 x가 제곱수인지를 확인
//lpow(x)는 x보다 작은 제곱수
//hpow(x)는 x보다 큰 제곱수
y-=x;
if(ifpow(y))
	res=sqrt(y)*2-1;
else if((lpow(y)+1+hpow(y))/2<=y) {
	res=(int)sqrt(y)*2+1;
}
else
	res=(int)sqrt(y)*2;
```
