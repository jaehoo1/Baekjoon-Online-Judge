# [2784 : 가로 세로 퍼즐](https://www.acmicpc.net/problem/2784)
https://www.acmicpc.net/problem/2784

## 아이디어
Brute Force, Implementation

6개의 문자열 중 3개를 배치해 가로 세로 퍼즐을 풀어야 하므로, 6개 중 3개를 선택하는 순열 함수를 구현해 그 순열에 있는 문자열로 퍼즐을 만들고 퍼즐이 정답인지 검토하는 함수로 구현하였다.

조합(순열) 만들기
```java
static List<int[]> combinations = new ArrayList<>();

static void backtracking(int[] arr, int depth, int idx) {

    if (idx == 6) {
        return;
    }
    arr[depth] = idx;
    if (depth == 2) {
        combinations.add(Arrays.copyOf(arr, 3));
        return;
    }
    for (int i = 0; i < 6; i++) {
        backtracking(arr, depth + 1, i);
    }
}

static void makeCombinations() {

    for (int i = 0; i < 6; i++) {
        backtracking(new int[3], 0, i);
    }
}

makeCombinations();
```

입력에 주어지는 문자열 개수 구하기  
(문자열 개수로 퍼즐의 정답을 체크)
```java
static String[] words = new String[6];
static Map<String, Integer> wordsCount = new HashMap<>();

Scanner sc = new Scanner(System.in);

for (int i = 0; i < 6; i++) {
    words[i] = sc.next();
    wordsCount.merge(words[i], 1, Integer::sum);
}
```

조합을 하나씩 선택해서 조합에 있는 인덱스로 퍼즐을 생성하고 퍼즐이 정답인지를 확인
```java
static String[] makePuzzleByCombination(int[] combination) {

    String[] puzzle = new String[3];
    for (int i = 0; i < 3; i++) {
        puzzle[i] = words[combination[i]];
    }
    return puzzle;
}

static String[] wordsInPuzzle(String[] puzzle) {

    String[] words = new String[6];
    for (int i = 0; i < 3; i++) {
        StringBuilder row = new StringBuilder();
        StringBuilder col = new StringBuilder();
        for (int j = 0; j < 3; j++) {
            row.append(puzzle[i].charAt(j));
            col.append(puzzle[j].charAt(i));
        }
        words[i * 2] = row.toString();
        words[i * 2 + 1] = col.toString();
    }
    return words;
}

static boolean isValidPuzzle(String[] puzzle) {

    Map<String, Integer> counts = new HashMap<>();
    for (String word : wordsInPuzzle(puzzle)) {
        counts.merge(word, 1, Integer::sum);
    }

    for (String word : wordsCount.keySet()) {
        if (wordsCount.get(word) != counts.get(word)) {
            return false;
        }
    }
    return true;
}

static boolean isValidPuzzle(int[] combination) {

    return isValidPuzzle(makePuzzleByCombination(combination));
}

for (int[] combination : combinations) {
    if (isValidPuzzle(combination)) {
        String[] result = makePuzzleByCombination(combination);
        for (int i = 0; i < 3; i++) {
            System.out.println(result[i]);
        }
        System.exit(0);
    }
}
System.out.println(0);
```