# [6243 : Mileage Bank](https://www.acmicpc.net/problem/6243)
https://www.acmicpc.net/problem/6243

## 문제
**문제**  
ACM(Airline of Charming Merlion)의 마일리지 프로그램은 자주 비행하는 여행객들에게 매우 좋은 프로그램입니다. ACM으로 비행을 완료하면 실제 비행한 거리에 따라 ACM 마일리지 뱅크에 ACMPerk 마일을 적립할 수 있습니다. 또한 마일리지 뱅크에 있는 ACMPerk 마일리지를 사용하여 향후 ACM의 무료 항공권으로 교환할 수 있습니다.

다음 표는 ACM을 이용할 때 얻을 수 있는 ACMPerk 마일을 계산하는 데 도움이 됩니다:
<table>
    <tr>
        <td><strong>비행 클래스</strong></td><td><strong>클래스 코드</strong></td><td><strong>적립 마일리지</strong></td>
    </tr>
    <tr>
        <td>퍼스트 클래스</td><td>F</td><td>실제 마일리지 + 100% 마일리지 보너스</td>
    </tr>
    <tr>
        <td>비즈니스 클래스</td><td>B</td><td>실제 마일리지 + 50% 마일리지 보너스</td>
    </tr>
    <tr>
        <td rowspan="2">이코노미 클래스</td><td rowspan="2">Y</td><td>1-500마일: 500마일</td>
    </tr>
    <tr>
        <td>500+마일: 실제 마일리지</td>
    </tr>
</table>

ACMPerk 마일리지는 두 부분으로 구성됩니다. 하나는 실제 비행 마일리지(이코노미 클래스의 경우 한 비행당 최소 ACMPerk 마일리지는 500마일)이고, 다른 하나는 비즈니스 클래스와 퍼스트 클래스를 이용할 때의 마일리지 보너스(1마일 단위까지 정확)입니다. 예를 들어, 베이징에서 도쿄까지 비행할 경우(실제 마일리지는 1329마일) Y, B, F 클래스에 대해 각각 1329, 1994, 2658 ACMPerk 마일을 얻을 수 있습니다. 상하이에서 우한까지 비행할 경우, 이코노미 클래스는 ACMPerk 500마일, 비즈니스 클래스는 ACMPerk 650마일을 얻을 수 있습니다(상하이와 우한 사이의 실제 마일리지는 433마일입니다).

당신의 과제는 ACM이 ACMPerk 마일리지를 자동으로 계산하는 프로그램을 만드는 것을 돕는 것입니다.

<br/>

**입력**  
입력 파일에는 여러 개의 데이터 케이스가 포함되어 있습니다. 각 케이스에는 여러 개의 비행 기록이 있으며, 각각 한 줄에 하나씩 있습니다. 비행 기록은 다음 형식을 따릅니다:
```text
출발도시 도착도시 실제마일리지 클래스코드
```

각 케이스는 0이 하나인 줄로 끝납니다.

#이 하나인 줄은 입력 파일의 끝을 나타냅니다.

<br/>

**출력**  
각 테스트 케이스에 대한 ACMPerk 마일리지의 합계를 한 줄에 하나씩 출력합니다.

<br/>

번역 출처 : https://www.acmicpc.net/board/view/154136

## 아이디어
Arithmetic(Math), Implementation

입력 처리에 대한 구현이 좀 필요하다 (현재 케이스 종료 분기 / 프로그램 종료 분기)
```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

int mileage = 0;
while (true) {
    StringTokenizer st = new StringTokenizer(br.readLine());
    String originalCity = st.nextToken();       // 첫 입력으로 출발도시 / 프로그램 종료 커맨드(#) / 현재 케이스 종료 커맨드(0)가 들어올 수 있다.
    if (originalCity.equals("#")) {             // 프로그램 종료 커맨드
        break;
    }
    if (originalCity.equals("0")) {             // 현재 케이스 종료 커맨드
        bw.write(mileage + "\n");               // 현재 까지의 합산된 마일리지 출력 후
        mileage = 0;                            // 다음 케이스 마일리지 초기화
        continue;                               // 밑의 로직들은 수행하면 안되
    }
```

이제 도착지, 마일리지, 클래스코드를 입력받아 분기에 따른 마일리지를 구하고 합산한다.
```java
    st.nextToken();                                             // 도착지 이름 필요 없음
    int actualMiles = Integer.parseInt(st.nextToken());         // 실제 마일리지
    char classCode = st.nextToken().charAt(0);                  // 클래스에 따른 분기처리
    if (classCode == 'F') {
        mileage += actualMiles * 2;
    } else if (classCode == 'B') {
        mileage += Math.round((double) actualMiles * 1.5);
    } else if (actualMiles <= 500) {
        mileage += 500;
    } else {
        mileage += actualMiles;
    }
}
```