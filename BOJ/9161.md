## 문제
**문제**  
지혜로운 베다비어 경은 종종 일반적이지 않은 논리를 사용해 괜찮은 결과를 도출합니다. 이번 약분에 관해서도 마찬가지입니다. 그는 분자와 분모 각 자리 수 중 같은 수가 있을 경우 지우는 것이 정답을 도출한다고 믿습니다. 물론 베다비어 경은 이를 세 자리 수 중 아주 적은 표본에만 적용해 봤습니다. 아래 약분 문제에서 베디비어 경의 풀이를 확인할 수 있습니다. (이 경우 그는 공통 숫자 6을 지웁니다.):  

166 / 664 =  16 / 64  

이 분수를 약분하면 16"6"의 6과 "6"64의 6이 지워집니다.  
당신은 아래의 조건을 만족하는 세 자리 수의 조합을 모두 찾아야 합니다:  

위 숫자(분자)의 가장 오른쪽 자리의 수와 아래 숫자(분모)의 가장 왼쪽 자리의 수가 같아 둘을 지워도 계산 결과가 달라지지 않는 조합.  
(222/222 = 22/22와 같이) xxx/yyy = xx/yy 꼴의 사소한 케이스는 모두 생략합니다. 정답은 위 숫자(분자) 기준으로 오름차순으로 출력합니다.  

<br/>

**입력**  
None! 이 문제의 입력은 없습니다.  

<br/>

**출력**  
한 줄에 하나씩 아래와 같은 형식으로 엉터리 약분 사례를 출력합니다. (아래 예시는 형식을 보여주기 위해 일부만 제공한 것입니다.) - 공백이 아닌 문자들은 각각 하나의 공백으로 구분합니다.  

<br/>

번역 출처 : https://www.acmicpc.net/board/view/87600

## 아이디어
Brute Force, Arithmetic, Implement  
  
문제의 조건에 맞게 코드를 구현하고  
세 자리수에 국한되니 모든 경우의 수를 탐색
```c
int samedigit(int num) {
	char str[4];
	sprintf(str, "%d", num);
	if(str[0]==str[1]&&str[0]==str[2])
		return 1;
	return 0;
}

int a, b, eraseda, erasedb;
for(a=100 ; a<1000 ; a++) {
	eraseda=a/10;
	for(b=100 ; b<1000 ; b++) {
		erasedb=b%100;
		if(!erasedb)
			continue;
		if(samedigit(a)&&samedigit(b))
			continue;
		if(a*(b%100)==(a/10)*b&&a%10==b/100)
			printf("%d / %d = %d / %d\n", a, b, eraseda, erasedb);
	}
}
```
