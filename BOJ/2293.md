## 아이디어
Dynamic Programming  
  
메모리 제한이 4MB인것을 보아하니 1차원 DP로 해결해야함  
  
동전들이 비내림차순(오름차순)으로 주어질 거란  
보장이 없으니 입력 받은 뒤 정렬
```c
int intcmp(const int *a, const int *b) { return *a>*b; }

int coin[100], n, k, i;

scanf("%d%d", &n, &k);
for(i=0 ; i<n ; i++)
	scanf("%d", &coin[i]);
qsort(coin, n, 4, (int(*)(const void*, const void*))intcmp);
```
문제의 예제로 설명
```
3 10
1
2
5
```
가장 작은 코인(정렬 후 `coin[0]`)으로 `dp[]` 테이블을 초기화  
가장 작은 동전으로 만들 수 있는 경우 1가지를 센다  
(1원으로만 1~10원을 만드는 경우의 수)
|`dp[money]`|1|2|3|4|5|6|7|8|9|10|
|---|---|---|---|---|---|---|---|---|---|---|
|`coin[0]`|**1**|**1**|**1**|**1**|**1**|**1**|**1**|**1**|**1**|**1**|
```c
int dp[100001]={0, };

for(i=coin[0] ; i<=k ; i+=coin[0])
	dp[i]++;
```
다음 동전에 해당하는 `dp[coin[i]]` 를 1 증가 시켜준다  
(`coin[i]`원으로 `coin[i]`원을 구성하는 경우의 수)  
(현재는 `i==1`이라 `coin[1]==2`)
|`dp[money]`|1|2|3|4|5|6|7|8|9|10|
|---|---|---|---|---|---|---|---|---|---|---|
|`coin[1]`|1|**2**|1|1|1|1|1|1|1|1|

money원에서 `coin[i]`를 빼서 만들 수 있는 동전 경우의 수를 더해준다  
(3원을 2원 동전으로도 구성하려면 3-2원을 구성하는 경우의 수에 2원 동전 경우의 수를 더하면 됨)
|`dp[money]`|1|2|3|4|5|6|7|8|9|10|
|---|---|---|---|---|---|---|---|---|---|---|
|`coin[1]`|1|2|**2**|**3**|**3**|**4**|**4**|**5**|**5**|**6**|

위 과정을 코드화하여 동전 종류 수 만큼 반복
```c
int j;

for(i=1 ; i<n ; i++) {
	dp[coin[i]]++;
	for(j=coin[i]+1 ; j<=k ; j++)
		dp[j]+=dp[j-coin[i]];
}
```
|`dp[money]`|1|2|3|4|5|6|7|8|9|10|
|---|---|---|---|---|---|---|---|---|---|---|
|`coin[2]`|1|2|2|3|**4**|4|4|5|5|6|

|`dp[money]`|1|2|3|4|5|6|7|8|9|10|
|---|---|---|---|---|---|---|---|---|---|---|
|`coin[2]`|1|2|2|3|4|**5**|**6**|**7**|**8**|**10**|
