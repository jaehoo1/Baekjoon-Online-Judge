## 문제
인접한 두마리의 소 i와 i + 1을 선택해서 옥수수 한봉지를 먹일 수 있음  
모든 소들이 음수가 아닌 같은 수의 배고픔이 되기를 원한다.  
먹이를 주는데 필요한 옥수수 최소 봉지를 구해라. 못 구할 경우 -1을 출력.

## 아이디어
Greedy  
  
앞에서 부터 순차탐색 구조로 생각하면  
이미 지나간 값에 대해 같게 만들 수 없으므로  
순차탐색 하면서 값을 같게 만들어 줘야함  
  
배열 입력
```c
int N, arr[100000], i;
scanf("%d", &N);
for(i=0 ; i<N ; i++)
	scanf("%d", &arr[i]);
```
순차탐색 중 뒷 인덱스 값(`arr[i+1]`)이 현재 인덱스 값(`arr[i]`)보다 크면  
그 차이만큼 `arr[i+1]`, `arr[i+2]` 에서 빼줘서 우선은 같은 숫자로 만들어준다  
(예를 들어, `8 10 5` 가 있다면 8과 10의 차이인  
2만큼 10과 5에서 빼줘서 `8 8 3`으로 만든다)  
배열안에 최소값도 같이 구한다
```c
int min=1000000001;
long long res=0;
for(i=0 ; i<N ; i++) {
	if(i<N-2&&arr[i]<arr[i+1]) {
		temp=arr[i+1]-arr[i];
		arr[i+1]-=temp;
		arr[i+2]-=temp;
		res+=temp*2;
	}
	if(arr[i]<min)
		min=arr[i];
}
```
첫 번째 순차탐색에서 값을 같게 만들면서 최소값을 찾았으므로,  
이제 이 최소값이 아닌 값들을 최소값으로 만들어 준다  
값을 변경할 때는 반드시 인접한 값과 함께 변경할 수 있다
```c
for(i=0 ; i<N ; i++) {
	if(arr[i]!=min&&i<N-1&&arr[i]==arr[i+1]) {
		temp=arr[i]-min;
		arr[i]-=temp;
		arr[i+1]-=temp;
		res+=temp*2;
	}
	if(arr[i]!=min||arr[i]<0) {
		res=-1;
		break;
	}
}
```
