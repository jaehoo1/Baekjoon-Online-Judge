# [27983 : 리본 (Easy)](https://www.acmicpc.net/problem/27983)
https://www.acmicpc.net/problem/27983

## 아이디어
Brute Force, Implementation

거리, 길이, 색 입력
```java
static int[] X;
static int[] L;
static char[] C;


BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

int N = Integer.parseInt(br.readLine());
X = new int[N];
L = new int[N];
C = new char[N];
StringTokenizer st = new StringTokenizer(br.readLine());
for (int i = 0; i < N; i++) {
    X[i] = Integer.parseInt(st.nextToken());
}
st = new StringTokenizer(br.readLine());
for (int i = 0; i < N; i++) {
    L[i] = Integer.parseInt(st.nextToken());
}
st = new StringTokenizer(br.readLine());
for (int i = 0; i < N; i++) {
    C[i] = st.nextToken().charAt(0);
}
```

아름다움 판별을 코드로 구현한다.
```java
static int distance(int i, int j) {
    return Math.abs(X[i] - X[j]);
}

static int length(int i, int j) {
    return L[i] + L[j];
}

static boolean isBeautiful(int i, int j) {
    return distance(i, j) <= length(i, j) && C[i] != C[j];
}
```

$N$이 작으므로 모든 가능한 리본 두 쌍이 아름다운지 확인한다.
```java
for (int i = 0; i < N - 1; i++) {
    for (int j = i + 1; j < N; j++) {
        if (isBeautiful(i, j)) {
            System.out.println("YES");
            System.out.println((i + 1) + " " + (j + 1));
            System.exit(0);
        }
    }
}
System.out.println("NO");
```