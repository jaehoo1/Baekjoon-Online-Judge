# [28356 : 부정행위 멈춰!](https://www.acmicpc.net/problem/28356)
https://www.acmicpc.net/problem/28356

## 아이디어
Constructive, Greedy

K값을 최소화 해야 하므로 한 칸 한 칸(시험지 번호)을 채울 때 가능한 가장 작은 수로 채워줘야 한다.

한 칸의 번호는 인접 칸 중 가능한 가장 작은 것으로 선택할 수 있다.
```java
static final int[] nx = {-1, -1, 0, 1, 1, 1, 0, -1}, ny = {0, 1, 1, 1, 0, -1, -1, -1};

static int getPositionTestNum(int[][] tests, int x, int y) {
    boolean[] testNum = new boolean[5];
    for (int i = 0; i < 8; i++) {
        int nextx = x + nx[i];
        int nexty = y + ny[i];
        if (nextx < 0 || nextx >= tests.length || nexty < 0 || nexty >= tests[0].length) {
            continue;
        }
        testNum[tests[nextx][nexty]] = true;
    }
    for (int i = 1; i <= 4; i++) {
        if (!testNum[i]) {
            return i;
        }
    }
    return -1;
}
```

칸을 채울 때 마다 최대값을 갱신해 K의 값을 구한다. (참고로 K는 4를 초과할 수 없다)
```java
Scanner sc = new Scanner(System.in);
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
int N = sc.nextInt();
int M = sc.nextInt();
int K = 1;
int[][] tests = new int[N][M];
for (int i = 0; i < N; i++) {
    for (int j = 0; j < M; j++) {
        tests[i][j] = getPositionTestNum(tests, i, j);
        K = Math.max(K, tests[i][j]);
    }
}
bw.write(K + "\n");
for (int i = 0; i < N; i++) {
    for (int j = 0; j < M; j++) {
        bw.write(tests[i][j] + " ");
    }
    bw.write("\n");
}
```