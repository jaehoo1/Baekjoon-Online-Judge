# [24447 : 알고리즘 수업 - 너비 우선 탐색 4](https://www.acmicpc.net/problem/24447)
https://www.acmicpc.net/problem/24447

## 아이디어
BFS(Graph Traversal, Graph Theory), Sorting

정점들의 간선 입력
```java
static int N;
static List<Integer>[] edges;

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer st = new StringTokenizer(br.readLine());
N = Integer.parseInt(st.nextToken());
int M = Integer.parseInt(st.nextToken());
int R = Integer.parseInt(st.nextToken());
edges = new List[N + 1];
for (int i = 1; i <= N; i++) {
    edges[i] = new ArrayList<>();
}
while (M-- > 0) {
    st = new StringTokenizer(br.readLine());
    int u = Integer.parseInt(st.nextToken());
    int v = Integer.parseInt(st.nextToken());
    // 양방향
    edges[u].add(v);
    edges[v].add(u);
}
```

인접 정점은 오름차순으로 방문한다. → 간선 정렬
```java
for (int i = 1; i <= N; i++) {
    Collections.sort(edges[i]);
}
```

d, t 배열 초기화
```java
static int[] depths;
static int[] traversalOrders;

depths = new int[N + 1];
traversalOrders = new int[N + 1];
Arrays.fill(depths, -1);
Arrays.fill(traversalOrders, 0);
```

R 정점에서 시작하는 `bfs()` 메서드 구현
```java
static long bfs(int start) {

    boolean[] visited = new boolean[N + 1];
    int order = 1;
    Queue<Integer> queue = new LinkedList<>();
    visited[start] = true;
    depths[start] = 0;
    traversalOrders[start] = order++;
    queue.offer(start);
    while (!queue.isEmpty()) {
        int cur = queue.poll();
        for (int i = 0; i < edges[cur].size(); i++) {
            int next = edges[cur].get(i);
            if (visited[next]) {
                continue;
            }
            visited[next] = true;
            depths[next] = depths[cur] + 1;
            traversalOrders[next] = order++;
            queue.offer(next);
        }
    }
    long result = 0;
    for (int i = 1; i <= N; i++) {
        result += (long) depths[i] * traversalOrders[i];
    }
    return result;
}

System.out.println(bfs(R));
```