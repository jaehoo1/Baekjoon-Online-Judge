# [27481 : Hotelier](https://www.acmicpc.net/problem/27481)
https://www.acmicpc.net/problem/27481

## 문제
**문제**  
아무개에는 $10$개의 객실로 구성된 호텔을 소유하고 있습니다. 객실 번호는 왼쪽에서 오른쪽으로 $0$번부터 $9$번까지입니다.

호텔에는 왼쪽 끝과 오른쪽 끝에 두 개의 입구가 있습니다. 고객이 왼쪽 입구를 통해 호텔에 도착하면 왼쪽 입구에 가장 가까운 빈 방으로 배정됩니다. 마찬가지로 고객이 오른쪽 입구를 통해 호텔에 도착하면 오른쪽 입구에 가장 가까운 빈 방으로 배정됩니다.

어느 날 아무개는 방 배정 목록을 잃어버렸습니다. 다행히 아무개의 기억은 완벽하며 고객이 도착했을 때 어느 입구에서 왔는지, 고객이 호텔을 떠났는지 등 모든 고객의 정보를 기억합니다. 처음에는 호텔이 비어 있었습니다. 아무개의 기억에서 방 배정 목록을 복구하는 프로그램을 작성합니다.

<br/>

**입력**  
첫 번째 줄은 아무개의 기억에 있는 사건의 수인 정수 $n$ ($1\le n\le 10^5$)로 구성되어 있습니다.

두 번째 줄은 사건을 시간 순서대로 설명하는 길이 $n$의 문자열로 구성되어 있습니다. 각 문자는 다음을 나타냅니다:

'L': 왼쪽 입구에서 고객이 도착합니다.

'R': 오른쪽 입구에서 고객이 도착합니다.

'0', '1', '…, '9': 방 $x$에 있는 고객(각각 0, 1, ..., 9)이 떠납니다.

고객이 도착하면 빈 방이 하나 이상 있고, $x$번 방에 고객이 있는 것이 보장됩니다. 또한 모든 객실이 처음에는 비어 있습니다.

<br/>

**출력**  
유일한 줄에서 호텔 객실의 상태를 $0$번 객실에서 $9$번 객실 순서로 출력합니다. 빈 객실은 '0'으로, 고객이 있는 객실은 공백 없이 '1'로 표시합니다.

<br/>

번역 출처 : https://www.acmicpc.net/board/view/160865

## 아이디어
Simulation(Implementation)

방이 10개밖에 안되니 빈방을 찾는 로직을 순차탐색으로 구현해도 큰 무리가 없을 듯 하다.
```java
static boolean[] rooms = new boolean[10];

static int emptyRoomIndex(char startAt) {
    int i;
    if (startAt == 'L') {
        for (i = 0; i < 10 && rooms[i]; i++);
    } else {    // R
        for (i = 9; i >= 0 && rooms[i]; i--);
    }
    return i;
}
```

손님이 도착할 때, 떠날 때 로직을 구현
```java
static void customerArrive(char startAt) {
    rooms[emptyRoomIndex(startAt)] = true;
}

static void customerLeave(int index) {
    rooms[index] = false;
}

static void customerLeave(char index) {
    customerLeave(index - '0');
}
```

입력에 대해 손님이 입실인지 퇴실인지 처리하고 방의 상태를 출력한다.
```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

int n = Integer.parseInt(br.readLine());
char[] chars = br.readLine().toCharArray();
for (char c : chars) {
    if (c == 'L' || c == 'R') {     // 입실(도착)
        customerArrive(c);
    } else {                        // 퇴실(떠남)
        customerLeave(c);
    }
}
for (int i = 0; i < 10; i++) {
    System.out.print(rooms[i] ? 1 : 0);
}
```