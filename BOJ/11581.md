## 아이디어
Floyd Warshall  
  
플로이드 와샬 알고리즘으로  
자기 자신으로 돌아올 수 있는 노드를 찾는다  
  
노드 개수를 입력 받고 인접 행렬을 초기화한다  
일반적인 플로이드 문제에서는 `G[i][i] = 0`으로 초기화 하는데,  
이 문제에서 그렇게 해버리면 초기화 시점부터 자기 자신으로  
돌아오는 노드(사이클)가 생겨버리기 때문에,  
`G[i][i]` 역시 연결되지 않은 간선으로 저장해야 한다
```c
# define	INF	-1

int N, G[101][101], i, j;
scanf("%d", &N);
for(i=1 ; i<=N ; i++)
	for(j=1 ; j<=N ; j++)
		G[i][j]=INF;
```
간선을 입력 받고 그래프에 저장
```c
int M, C;
for(i=1 ; i<N ; i++) {
	scanf("%d", &M);
	while(M--) {
		scanf("%d", &C);
		G[i][C]=1;
	}
}
```
`노드 i`에서 `노드 k`를 거쳐서 `노드 j`로 갈 수 있다면  
`노드 i`에서 `노드 j`로 갈 수 있다
```c
for(k=1 ; k<=N ; k++)
	for(i=1 ; i<=N ; i++)
		for(j=1 ; j<=N ; j++)
			if(G[i][k]!=INF&&G[k][j]!=INF)
				G[i][j]=1;
```
`1번 노드`에서 도달할 수 있는 노드 중에서  
자기 자신으로 올 수 있는 노드가 있다면  
사이클이 발생할 수 있다
```c
for(i=1 ; i<=N ; i++)
	if(G[1][i]!=INF&&G[i][i]!=INF) {
		puts("CYCLE");
		return 0;
	}
puts("NO CYCLE");
```
