## 아이디어
Dynamic Programming, Longest Common Subsequence  
dp 테이블을 채워가며 최장 공통 부분 수열을 찾는 문제  
  
표를 채워간다  
행과 열의 알파벳이 같은 곳을  
[i-1][j-1]의 값에 +1 해준다  
예제 :  
ABRACADABRA  
ECADADABRBCRDARA  
||A|B|R|A|C|A|D|A|B|R|A|
|---|---|---|---|---|---|---|---|---|---|---|---|
|E||||||||||||
|C|||||1|||||||
|A|1|||1||2||1|||1|
|D|||||||3|||||
|A|1|||1||1||4|||1|
|D|||||||2|||||
|A|1|||1||1||3|||1|
|B||2|||||||4|||
|R|||3|||||||**5**||
|B||1|||||||1|||
|C|||||1|||||||
|R|||1|||||||1|
|D|||||||1|||||
|A|1|||1||1||2|||1|
|R|||1|||||||1||
|A|1|||2||1||1|||2|

```c
char A[4001], B[4001];
int dp[4000][4000]={0, }, i, j, max=0;

scanf("%s%s", A, B);
for(i=0 ; A[i] ; i++)
	for(j=0 ; B[j] ; j++)
		if(A[i]==B[j]) {
			if(!i||!j)
				dp[i][j]=1;
			else
				dp[i][j]=dp[i-1][j-1]+1;
			if(dp[i][j]>max)
				max=dp[i][j];
		}
```
