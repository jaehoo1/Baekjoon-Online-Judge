# [34803 : 문자열 로또](https://www.acmicpc.net/problem/34803)
https://www.acmicpc.net/problem/34803

## 아이디어
(Hash) Map(Data Structure), Brute Force, String

$L$, $N$, $K$ 가 별로 큰 편이 아니므로 가능한 모든 부분 문자열을 구해 각 부분 문자열이 몇 번이 나왔는지를 세어두고 그 중 길이가 $K$ 인 것중 가장 큰(점수가 많은) 것을 찾으면 된다.

모든 부분 문자열 구하는 로직 구현
```java
static List<String> substrings(String s) {
    List<String> substrings = new ArrayList<>();
    for (int i = 0; i < s.length(); i++) {
        for (int j = i + 1; j <= s.length(); j++) {
            substrings.add(s.substring(i, j));
        }
    }
    return substrings;
}
```

입력된 문자열 들에서 부분 문자열이 몇 번 나왔는지 카운팅
```java
static Map<String, Integer> substringCount = new HashMap<>();


BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

StringTokenizer st = new StringTokenizer(br.readLine());
st.nextToken();
int N = Integer.parseInt(st.nextToken());
while (N-- > 0) {
    substrings(br.readLine())
            .forEach(s -> substringCount.compute(s, (k, v) -> v == null ? 1 : v + 1));
}
```

부분 문자열 중에 길이가 $K$ 인 것 중 가장 큰 값 찾기
```java
int K = Integer.parseInt(br.readLine());
Optional<Map.Entry<String, Integer>> optional = substringCount.entrySet().stream()
        .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
        .filter(entry -> entry.getKey().length() == K)
        .findFirst();
System.out.println(optional.isPresent() ? optional.get().getValue() : 0);
```