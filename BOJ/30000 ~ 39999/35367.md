# [35367 : Snakey String](https://www.acmicpc.net/problem/35367)
https://www.acmicpc.net/problem/35367

## 아이디어
String, Implementation

맨 처음에는 그래프 탐색(bfs)으로 구현을 했었는데
```java
class Position {

    int x, y;

    public Position(int x, int y) {
        this.x = x;
        this.y = y;
    }
}


static final int[] DX = {-1, 1};

static char[][] grid;
static int r, c;

static String bfs(Position start) {

    StringBuilder sb = new StringBuilder();
    Queue<Position> queue = new LinkedList<>();
    queue.add(start);
    while (!queue.isEmpty()) {
        Position cur = queue.poll();
        sb.append(grid[cur.x][cur.y]);
        for (int i = 0; i < 2; i++) {
            int nextx = cur.x + DX[i];
            int nexty = cur.y + 1;
            if (nextx >= r || nextx < 0 || nexty >= c || grid[nextx][nexty] == '.') {
                continue;
            }
            queue.add(new Position(nextx, nexty));
        }
    }
    return sb.toString();
}
```

풀고 나서 생각해보니 그냥 각 열 마다 문자가 있는 행을 찾아 출력해주기만 하면 된다(단순 완전 탐색).
```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

StringTokenizer st = new StringTokenizer(br.readLine());
int r = Integer.parseInt(st.nextToken());
int c = Integer.parseInt(st.nextToken());
char[][] grid = new char[r][c];
for (int i = 0; i < r; i++) {
    grid[i] = br.readLine().toCharArray();
}
for (int j = 0; j < c; j++) {
    for (int i = 0; i < r; i++) {
        if (grid[i][j] != '.') {
            bw.write(grid[i][j]);
        }
    }
}
```