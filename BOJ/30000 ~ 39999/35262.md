# [35262 : 지금부터 완장 찬양을 시작하겠습니다](https://www.acmicpc.net/problem/35262)
https://www.acmicpc.net/problem/35262

## 아이디어
Implementation

맨 처음에는 java로 구현하였었다.
```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

StringTokenizer st = new StringTokenizer(br.readLine());
st.nextToken();
System.out.println(br.readLine().contains("0".repeat(Integer.parseInt(st.nextToken()))) ? 0 : 1);
```

그런데 시간 초과가 났다. `String.contains()`는 $O(N)$으로 알고 있었는데 어떻게 된 것이지?  
Python에서 동일 로직, 시간 복잡도라고 생각했던 `in` / `str.find()`는 통과가 된다.
```python
N, K = map(int, input().split())
print(0 if "0" * K in input() else 1)
```

### Python
#### 내부 알고리즘
CPython은 문자열 검색에 Two-Way String Matching Algorithm 사용

#### 시간복잡도
$O(N + K) ≈ O(N)$  
 → 선형 시간 보장

- 반복 패턴에서도 성능 저하 거의 없음
- 대규모 입력에서도 안정적으로 통과

### Java
#### 내부 알고리즘
`String.contains()`는 내부적으로 `String.indexOf()`를 호출하며, 해당 구현은 KMP 같은 선형 시간 알고리즘이 아니라 문자 비교 기반의 단순 탐색 방식이다. 따라서 반복 패턴에서 최악의 경우 $O(N × M)$의 시간복잡도를 가질 수 있다.

Pseudo code:
```text
for i in 0 ~ N-K:
    j = 0
    while s[i+j] == pattern[j]:
        j++
```

#### 시간복잡도 (최악)
$O(N × K)$

최악 케이스 예시
```text
N = 10000
K = 5000
S = "0000000000000000000001"
```

동작 과정:
- 거의 모든 위치에서
- K개 가까이 비교 후 마지막에서 실패

즉,
```text
N번 × K번 비교
```
→ 거의 N × K 연산 발생

### 알고리즘 차이 비교
|항목|Python `in`|Java `String.contains()`|
|---|---|---|
|내부 알고리즘|Two-Way|Naive|
|최악 시간복잡도|$O(N+K)$|$O(N×K)$|
|반복 문자 패턴 대응|강함|매우 약함|
|선형 시간 보장|예|아니오|