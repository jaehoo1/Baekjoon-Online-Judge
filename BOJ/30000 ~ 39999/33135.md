# [33135 : Append and Panic!](https://www.acmicpc.net/problem/33135)
https://www.acmicpc.net/problem/33135

## 문제
**문제**  
오늘은 가브리엘이 새 직장에 출근하는 첫날로, 첫 번째 임무를 맡게 되었습니다. 가브리엘은 파일에서 대문자로 구성된 문자열을 읽고 문자열의 문자를 알파벳순으로 정렬한 다음 반복되는 문자를 걸러낸 다음 결과를 원래 파일에 다시 써야 합니다. 예를 들어 문자열 "`ICPC`"를 정렬하면 "`CCIP`"가 생성되며, 반복되는 문자를 제거한 후 "`CIP`"가 됩니다. 쉽죠?

하지만 가브리엘은 작은 실수를 저질렀습니다. 필터링된 문자열로 파일을 덮어쓰는 대신 실수로 파일에 추가했습니다. 이제 파일이 손상되어 원본 문자열 뒤에 중복이 없는 정렬된 버전이 포함되어 가브리엘은 약간 당황합니다.

손상된 파일의 내용을 고려할 때 원본 문자열의 길이를 결정할 수 있나요? 가브리엘은 이 정보를 통해 할당된 작업을 완료할 수 있을 것이라고 확신합니다.

<br/>

**입력**  
입력은 대문자(2 ≤ $|S|$ ≤ 2000)로 구성된 문자열 $S$를 포함하는 단일 줄로 구성되어 있습니다. 이 줄은 원래(파열되지 않은) 문자열 $t$와 중복이 없는 정렬된 버전 $t$의 연결입니다.

<br/>

**출력**  
$t$의 길이를 나타내는 정수가 있는 단일 선을 출력합니다.

<br/>

번역 출처 : https://www.acmicpc.net/board/view/161649

## 아이디어
String, Implementation

중복을 제거하면 원래의 답(알파벳순으로 정렬 후 중복 제거)의 길이를 구할 수 있다. 손상된 파일(입력)의 길이에서 이것을 빼면 원본의 길이를 구할 수 있다.
```java
String s = new BufferedReader(new InputStreamReader(System.in)).readLine();
Set<Character> set = new HashSet<>();
for (int i = 0; i < s.length(); i++) {
    set.add(s.charAt(i));
}
System.out.println(s.length() - set.size());
```