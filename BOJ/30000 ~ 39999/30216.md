# [30216 : Increasing Sublist](https://www.acmicpc.net/problem/30216)
https://www.acmicpc.net/problem/30216

## 문제
숫자 리스트가 주어졌을 때, 부분 리스트는 리스트에서 하나 이상의 연속된 원소들로 정의됩니다. 증가하는 부분 리스트는 연속된 원소들이 엄격하게 증가하는 순서로 되어있는 경우를 말합니다. 즉, 부분 리스트의 각 원소는 왼쪽에 있는 원소보다 커야 합니다(부분 리스트의 첫 번째 원소는 제외).

주어진 리스트에서 가장 긴 증가하는 부분 리스트의 길이(원소의 개수)를 찾으세요.

<br/>

**입력**  
첫 번째 입력 줄에는 리스트의 원소 개수를 나타내는 정수 n (1 ≤ n ≤ 30)이 주어집니다. 다음 입력 줄에는 리스트의 n개 원소가 제공됩니다. 각 원소는 1에서 100 사이의 정수입니다.

<br/>

**출력**  
가장 긴 증가하는 부분 리스트의 길이(원소의 개수)를 출력하세요.

<br/>

번역 출처 : https://www.acmicpc.net/board/view/152464

## 아이디어
Brute Force, Implementation

LIS 문제이긴 한데, 제한(n)도 작고 원소들은 연속되어야 한다는 조건이 붙는다.  
연속이라는 조건이 있으니 각 원소별로 증가할 때 까지 카운트를 세어주면 된다.
```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

int n = Integer.parseInt(br.readLine());
int[] arr = new int[n];
StringTokenizer st = new StringTokenizer(br.readLine());
for (int i = 0; i < n; i++) {
    arr[i] = Integer.parseInt(st.nextToken());
}
int max = 0;
for (int i = 0; i < n; i++) {
    // 각 원소별로 증가할 때 까지 LIS 길이를 구함
    List<Integer> lis = new ArrayList<>();
    lis.add(arr[i]);
    for (int j = i + 1; j < n && lis.get(lis.size() - 1) < arr[j]; j++) {
        lis.add(arr[j]);
    }
    max = Math.max(max, lis.size());
}
System.out.println(max);
```