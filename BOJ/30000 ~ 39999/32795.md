# [32795 : Intuitive Elements](https://www.acmicpc.net/problem/32795)
https://www.acmicpc.net/problem/32795

## 문제
Brandon이 주기율표를 배우고 있습니다! 하지만 그는 일부 원소들이 마음에 들지 않습니다. 그 이유는 원소 기호에 원소 이름에 없는 문자가 포함되어 있기 때문입니다. 그는 이것이 직관적이지 않다고 생각합니다. 특히 다른 맥락에서는 약자가 임의의 문자를 도입하지 않을 것이라고 기대하기 때문입니다.

문자열과 제안된 약자가 주어졌을 때, Brandon이 이를 직관적이라고 생각할지 판단하세요. Brandon은 약자에 나타나는 모든 문자가 원래 문자열에도 나타날 때만 그것을 직관적이라고 생각합니다. Brandon은 약자를 자세히 살펴보지 않기 때문에, 약자에서 어떤 문자가 원래 문자열보다 더 많이 나타나거나, 문자열과 약자 사이에서 문자들의 순서가 다른 것은 허용됩니다.

<br/>

**입력**  
입력의 첫 줄에는 하나의 정수 $t (1 ≤ t ≤ 10³)$가 주어집니다. 이는 테스트 케이스의 수입니다.

각 테스트 케이스는 두 줄로 이루어져 있습니다.

각 테스트 케이스의 첫 번째 줄에는 길이가 2 이상 50 이하인 하나의 문자열 $a$가 주어집니다. 이 문자열은 소문자로만 이루어져 있습니다. 테스트 케이스의 두 번째 줄에는 $a$보다 짧은 하나의 문자열 $b$가 주어지며, 이 역시 소문자로만 이루어져 있습니다.

<br/>

**출력**  
$t$개의 줄을 출력하세요. 각 줄은 하나의 테스트 케이스에 대응됩니다.
각 테스트 케이스에 대해, $b$의 모든 문자가 $a$에 나타나면 'YES'를 출력하고, 그렇지 않으면 'NO'를 출력하세요.

<br/>

번역 출처 : https://www.acmicpc.net/board/view/152909

## 아이디어
String, Implementation

약어의 모든 알파벳이 원소 알파벳에 들어있는지만 확인하면 된다. 순서와 중복은 상관 없다 → `Set<Character>`에 원소 알파벳들 저장 후 약어의 알파벳에 대해 검사
```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

int t = Integer.parseInt(br.readLine());
while (t-- > 0) {
    // 원소 알파벳들
    Set<Character> element = br.readLine()
            .chars()
            .mapToObj(c -> (char) c)
            .collect(Collectors.toSet());
    // 약어 알파벳 검사
    bw.write(
            br.readLine()
                    .chars()
                    .mapToObj(c -> (char) c)
                    .allMatch(element::contains)
                        ? "YES\n"
                        : "NO\n"
    );
}
```