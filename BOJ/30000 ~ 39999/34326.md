# [34326 : How to escape the maze](https://www.acmicpc.net/problem/34326)
https://www.acmicpc.net/problem/34326

## 아이디어
Grid Graph, Graph Traversal, Implementation

좌수법, 우수법의 의사 코드를 구현하고 이동거리를 구해 어떤게 더 짧은지 비교하면 된다.

좌표 클래스
```java
class Position {

    int x, y;

    public Position(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public Position(Position position) {
        this(position.x, position.y);
    }

    @Override
    public boolean equals(Object o) {
        Position position = (Position) o;
        return x == position.x && y == position.y;
    }
}
```

미로를 입력하고 시작지점, 끝지점을 찾는다.
```java
static char[][] maze;
static int N, M;

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer st = new StringTokenizer(br.readLine());
N = Integer.parseInt(st.nextToken());
M = Integer.parseInt(st.nextToken());
maze = new char[N][M];
for (int i = 0; i < N; i++) {
    maze[i] = br.readLine().toCharArray();
}
Position start = null, end = null;
for (int i = 0; i < N; i++) {
    for (int j = 0; j < M; j++) {
        if (maze[i][j] == 'S') {
            start = new Position(i, j);
        } else if (maze[i][j] == 'E') {
            end = new Position(i, j);
        }
    }
}
```

좌수법 / 우수법 구현
```java
/** 좌회전 */
static int leftTurn(int vec) {
    if (--vec < 0) {
        vec = 3;
    }
    return vec;
}

/** 우회전 */
static int rightTurn(int vec) {
    if (++vec >= 4) {
        vec = 0;
    }
    return vec;
}

/** 앞으로 갈 수 있는지? */
static boolean canMoveForward(int vec, Position cur) {
    int nextx = cur.x + nx[vec];
    int nexty = cur.y + ny[vec];
    if (nextx < 0 || nextx >= N || nexty < 0 || nexty >= M) {
        return false;
    }
    return maze[nextx][nexty] != '*';
}

/** 좌수법 */
static int leftHand(Position start, Position end) {
    int vec = 0, move = 0;
    for (int i = 0; i < 4; i++) {
        int nextx = start.x + nx[i];
        int nexty = start.y + ny[i];
        if (nextx < 0 || nextx >= N || nexty < 0 || nexty >= M || maze[nextx][nexty] != '.') {
            continue;
        }
        vec = i;
        break;
    }
    Position cur = new Position(start);
    while (!cur.equals(end)) {
        vec = leftTurn(vec);
        while (!canMoveForward(vec, cur)) {
            vec = rightTurn(vec);
        }
        cur.x += nx[vec];
        cur.y += ny[vec];
        move++;
    }
    return move;
}

/** 우수법 */
static int rightHand(Position start, Position end) {
    int vec = 0, move = 0;
    for (int i = 0; i < 4; i++) {
        int nextx = start.x + nx[i];
        int nexty = start.y + ny[i];
        if (nextx < 0 || nextx >= N || nexty < 0 || nexty >= M || maze[nextx][nexty] != '.') {
            continue;
        }
        vec = i;
        break;
    }
    Position cur = new Position(start);
    while (!cur.equals(end)) {
        vec = rightTurn(vec);
        while (!canMoveForward(vec, cur)) {
            vec = leftTurn(vec);
        }
        cur.x += nx[vec];
        cur.y += ny[vec];
        move++;
    }
    return move;
}
```

대소비교
```java
int left = leftHand(start, end);
int right = rightHand(start, end);
if (left < right) {
    System.out.println("LEFT IS BEST");
} else if (left > right) {
    System.out.println("RIGHT IS BEST");
} else {
    System.out.println("SAME");
}
```