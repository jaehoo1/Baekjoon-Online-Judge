# [31052 : Relocation](https://www.acmicpc.net/problem/31052)
https://www.acmicpc.net/problem/31052

## 문제
먼 나라 라인랜드에서는 기술 기업들이 자리 잡기 시작했습니다! 매주 기술 기업들이 땅에서 싹트거나 합병하거나 인수되거나 파산하는 것 같습니다. 라인랜드에서 새로운 일자리를 찾고 있는 소프트웨어 엔지니어들에게는 면접 대상 기업을 찾기조차 어려울 수 있습니다.

이 문제를 해결하기 위해 새로운 기술 회사를 만들어야 합니다! 제품은 간단합니다. 클라우드의 깊은 신경망 블록체인을 사용하여 앱이 라인랜드에 있는 두 기술 회사 간의 거리를 찾습니다. 이는 기업이 항상 사무실을 변경하고 완전히 최신 상태를 유지하기 어렵기 때문에 매우 유용합니다. 이 정보를 중앙 집중식으로 관리하면 회사는 더 나은 세상을 만들 수 있습니다.

라인랜드는 하나의 선을 중심으로 구성되어 있기 때문에 회사의 위치는 하나의 좌표로 지정할 수 있습니다. 두 회사 사이의 거리는 두 좌표 사이의 거리와 같습니다.

귀하의 업무는 회사의 플래그십 앱에 대한 두 가지 종류의 사용자 요청을 처리하는 것입니다. 한 종류의 요청은 회사의 주소를 업데이트하고 다른 종류의 요청은 두 회사 간의 최단 거리를 업데이트합니다.

<br/>

**입력**  
첫 번째 줄에는 두 개의 양의 공간 분리 정수 $N$과 $Q$가 있습니다: 앱이 추적하는 회사 수($2 \le N \le 100\, 000$)와 처리 요청 수($1 \le Q \le 100\, 000$)입니다. 다음 줄에는 공간 분리 정수 $N$개 $1 \le X_ i \le 10^9$가 있으며, 이는 $N$개 회사의 초기 위치로, $i=1$부터 $i=N$까지의 순서로 주어집니다.

다음 $Q$ 라인 각각은 $3$개의 공간으로 구분된 정수를 가지며, 다음과 같은 형태 중 하나를 취합니다.
- $1$ $C$ $X$는 회사 $C$가 위치를 $X$로 옮긴다는 것을 의미합니다
- $2$ $A$ $B$는 회사 $A$와 $B$ 사이의 거리에 대한 쿼리입니다.

$1 \leq A, B, C \leq N$ 및 $1 \leq X \leq 10^9$인 것이 보장됩니다. 두 회사가 동일한 위치를 공유할 수 있습니다. 또한 유형 $2$의 쿼리가 하나 이상 있는 것도 보장됩니다.

<br/>

**출력**  
유형 $2$의 각 쿼리에 대해 회사 $A$와 $B$ 사이의 거리를 출력합니다.

<br/>

번역 출처 : https://www.acmicpc.net/board/view/161321

## 아이디어
Implementation

회사들의 위치를 저장하는 배열을 생성하고 초기 위치를 저장
```java
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

StringTokenizer st = new StringTokenizer(br.readLine());
int N = Integer.parseInt(st.nextToken());
int Q = Integer.parseInt(st.nextToken());
int[] locations = new int[N + 1];
st = new StringTokenizer(br.readLine());
for (int i = 1; i <= N; i++) {  // 초기위치
    locations[i] = Integer.parseInt(st.nextToken());
}
```

쿼리를 입력받으며 회사 위치를 갱신하거나 회사 간 거리(절대값)를 구한다.
```java
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

while (Q-- > 0) {
    st = new StringTokenizer(br.readLine());
    String cmd = st.nextToken();
    int A = Integer.parseInt(st.nextToken());
    int B = Integer.parseInt(st.nextToken());
    if ("1".equals(cmd)) {              // 위치 갱신 쿼리
        locations[A] = B;
    } else if ("2".equals(cmd)) {       // 거리 계산 쿼리
        bw.write(Math.abs(locations[A] - locations[B]) + "\n");
    }
}
```