## 아이디어
Bitmask, Greedy  
  
예제 1을 생각해보면  
1리터 들어있는 물병 3개가 있는 상태에선  
1리터 물병 2개를 합쳐  
2리터 물병 1개, 1리터 물병 1개인 상태를 만들수가 있다  
→ 이 상태는 이진수로 표현이 가능하다  
`3` → `11(2)`  
`3`을 합치고 합치면 추가 물병 없이 2개의 물병이 됨  
  
예제 2를 생각해보면  
1리터 들어있는 물병 13개를 합치면  
8리터 물병 1개, 4리터 물병 1개, 1리터 물병 1개인 상태가 된다  
→ 이진수로 표현  
`13` → `1101(2)`  
  
즉, 이진수로 바꾸면 합쳤을 때 물병의 상태가 된다  
  
저 1들의 개수를 `K` 개 밑으로 (가장 적은 추가 물병을 사용하여) 줄여야 한다  
  
가장 뒷 자리의 1을 앞자리의 1과 합쳐질 때 까지 옮겨가면 될 것 같다
```text
예제 2의 경우 물병을 2개 이하로 줄여야 함
→ 1의 개수가 2개 이하로 만들어야 함

13 = 1101(2)
1101 → 1110 → 10000 = 16
16 - 13 = 3


예제 3의 경우 물병을 5개 이하로 줄여야 함
→ 1의 개수가 5개 이하로 만들어야 함

1000000 = 11110100001001000000(2)
11110100001001000000 →
11110100001010000000 →
11110100001100000000 →
11110100010000000000 →
11110100100000000000 →
11110101000000000000 →
11110110000000000000 →
11111000000000000000 = 1015808
1015808 - 1000000 = 15808
```
2의 n승에 해당하는 수를 알 필요가 있다  
(0001, 0010, 0100, 1000, … 을 배열에 저장한다)
```c
int bin[25]={1, }, i;
for(i=1 ; i<=24 ; i++)
	bin[i]=bin[i-1]*2;
```
`N`, `K`를 입력 받는다
```c
int N, K, orgN;
scanf("%d%d", &N, &K);
orgN=N;
```
현재 물병의 개수를 구하고  
`K`개 보다 많다면  
물병이 `K`개 이하가 될 때 까지  
위의 방식대로 뒤의 1을 앞으로 옮기는 것을 반복한다
```c
while(1) {
	bottle=0;
	for(i=0 ; i<=24 ; i++)
		if(N&bin[i])
			bottle++;
	if(bottle<=K)
		break;
	//원래 이 코드로 가장 뒤의 1을 구해 앞으로 옮겼는데
	//for(i=0 ; !(bin[i]&N) ; i++);
	//N+=bin[i];
	//생각해보니 아래 방식이 좋은 방식인 듯 하다
	N+=N&-N;  //이 의미를 잘 해석 해야함 → 2의 보수
}
printf("%d", N-orgN);
```
