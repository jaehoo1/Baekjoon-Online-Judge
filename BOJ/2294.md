## 아이디어 1 (MLE)
Dynamic Programming, dfs  
  
재귀 완전탐색 + dp로 모든 경우의 수를 구하려 했었는데  
[10001][10001]의 공간이 필요해 메모리 초과가 난다  
메모리를 적게 쓰는 방법이 필요하다
```c
int n, k, arr[100], dp[10001][10001];

int recur(int count, int money) {
	int i, min=10001, temp;
	if(money==k)
		return count;
	if(dp[count][money])
		return dp[count][money];
	for(i=0 ; i<n ; i++)
		if(money+arr[i]<=k) {
			temp=recur(count+1, money+arr[i]);
			if(temp<min)
				min=temp;
		}
	return dp[count][money]=min;
}
```
## 아이디어 2
Dynamic Programming  
k원을 만드는 최소 동전 개수는 min( k-arr[i] ) 를  
살펴봐서 +1( arr[i] 포함 ) 해주면 k원을 만드는 최소 동전 개수를  
구할 수 있겠다  
  
DP 테이블을 모두 최대값으로 초기화한다  
```c
int dp[10001];
for(i=0 ; i<=10000 ; i++)
	dp[i]=10001;
```
|i|1|2|3|4|5|...|
|---|---|---|---|---|---|---|
|dp|10001|10001|10001|10001|10001|...|

동전들을 입력받고 동전 1개로 만들 수 있는 금액을 처리  
(예제에선 1, 5, 12)  
```c
int n, k, arr[100];

scanf("%d%d", &n, &k);
for(i=0 ; i<n ; i++) {
	scanf("%d", &arr[i]);
	if(arr[i]<=10000)
		dp[arr[i]]=1;
}
```
|i|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|...|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|dp|1|10001|10001|10001|1|10001|10001|10001|10001|10001|10001|1|10001|10001|10001|...|

i원을 만드는 방법은 i원에서 arr[j](동전으로 주어진 값들)원을 빼서  
만들 수 있는 금액들 중 최소 동전 개수로 구성할 수 있는 경우들을 살펴보면 된다  
```c
int min;

for(i=1 ; i<=k ; i++) {
	min=10001;
	for(j=0 ; j<n ; j++)
		if(i-arr[j]>=1&&dp[i-arr[j]]<min)
			min=dp[i-arr[j]]+1;
	dp[i]=min<dp[i]?min:dp[i];
}
```

|i|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|...|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|dp|1|2|3|4|1|2|3|4|5|2|3|1|2|3|3|...|

ex :  
2원은 2-1원 + 1원으로 구성 가능  
3원은 3-1원 + 1원으로 구성 가능  
…  
6원은 6-1원 + 1원으로 구성 가능  
…  
10원은 10-5원 + 5원으로 구성 가능  
…  
15원은 15-5원 + 5원으로 구성 가능
